use super::undo_step::*;
use crate::traits::*;

use std::sync::*;

///
/// A log of undo elements
///
pub struct UndoLog {
    /// Set to true if we're currently performing an undo operation (retired edits won't be recorded)
    undoing: bool,

    /// The list of undo steps, with the latest at the end
    undo: Vec<UndoStep>,

    /// Steps that have been undone and which can be re-done
    redo: Vec<UndoStep>,
}

impl UndoLog {
    ///
    /// Creates a new empty undo log
    ///
    pub fn new() -> UndoLog {
        UndoLog {
            undoing:    false,
            undo:       vec![],
            redo:       vec![],
        }
    }

    ///
    /// Indicates that we're about to start an undo or a redo action
    ///
    pub fn start_undoing(&mut self) {
        self.undoing = true;
    }

    ///
    /// Indicates that we're finishing an undo or a redo action
    ///
    pub fn finish_undoing(&mut self) {
        self.undoing = false;
    }

    ///
    /// Retires an edit to this undo log
    ///
    pub fn retire(&mut self, edit: RetiredEdit) {
        // When in the undoing state, retiring edits has no effect (the edits are assumed to be generated by the undo action)
        if self.undoing { return; }
        
        let committed_edits = edit.committed_edits();

        // A 'prepare to undo' action on its own is always ignored (it's used for synchronising things up and will cause an editing mismatch)
        if committed_edits.len() == 1 {
            match committed_edits[0] {
                AnimationEdit::Undo(UndoEdit::PrepareToUndo(_)) => { return; }
                _                                               => { }
            }
        }

        // Create the initial undo step if needed
        if self.undo.is_empty() {
            self.undo.push(UndoStep::new());
        }

        // Any redo actions are destroyed when a new action is created
        self.redo.drain(..);

        // Determine if the edit finishes an action group
        let finishes_action_group = committed_edits.iter().any(|edit| match edit {
            AnimationEdit::Undo(UndoEdit::FinishAction) => true,
            _                                           => false,
        });

        // Add the edit to the current undo step
        self.undo.last_mut().unwrap().push_edit(edit);

        // Start a new action group if this edit finished one (and there were any actions performed in the last step)
        if finishes_action_group && self.undo.last().map(|last_step| !last_step.is_empty()).unwrap_or(true) {
            self.undo.push(UndoStep::new());
        }
    }

    ///
    /// Pops the action on top of the undo stack and moves it to the redo stack. Returns the edit to perform the action.
    ///
    /// Returns 'None' if the stack is empty.
    ///
    pub fn undo(&mut self) -> Option<UndoEdit> {
        // Pop up to two actions (in case the first one is empty)
        let most_recent_action = self.undo.pop()?;
        let most_recent_action = if most_recent_action.is_empty() { self.undo.pop()? } else { most_recent_action };

        let undo_edit = most_recent_action.undo_edit();

        // Add as a redo action
        self.redo.push(most_recent_action);

        // Add a new action group to the undo list so if there are any future actions, they won't extend an existing one
        self.undo.push(UndoStep::new());

        Some(undo_edit)
    }

    ///
    /// Pops the action on top of the redo stack and moves it to the undo stack. Returns the edit to perform the action.
    ///
    pub fn redo(&mut self) -> Option<Arc<Vec<AnimationEdit>>> {
        // Pop the next redo action and 
        let next_redo = self.redo.pop()?;
        let redo_edit = next_redo.redo_edit();

        // Add as an undo action
        self.undo.push(next_redo);

        Some(redo_edit)
    }
}
