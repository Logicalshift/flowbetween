use super::*;

use std::time::{Duration};

#[test]
fn collide_two_paths() {
    // Plus sign, combined into a path
    let edits = "
        +B
        LB+tAAAAAA
        LBPtAAAAAA*+BIAAAAg+AAAAoABAAAICB+
        LBPtAAAAAAP+CAAAAoABAAAg/AHAAAAAAAAAyCBAAAAAAAAAg/A
        LBPtAAAAAAS+AAiB+2FAAodjLHRF9PA8BAcNj5P1EA4AAAAAAAAAAAAAAGAAAAAAAAAAAAAACAAAAAAAAAAAAAADAAAAAAAAAAAAAANAAAAAAAAAAAAAAEAAAAAAAAlXAaIAEAAAAAAAA2MAsBACAAAAAAAAXPAGCACAAA8PAAArlAbEACAAAAAAAAGWAUCADAAAAAAAAbYA5BABAAAAAAAAVaArBABAAAAAAAAocAsBABAAAAAAAAieAQBABAAAAAAAAOgADBAAAAAAAAAA5hA1AAAAAAAAAAAXjAbAAAAAA4PAAAM3Cs9PAAAAAAAAAAkAU+PAAAA8PAAA8iAI+PAAAAAAAIAfhAU+PAAAAAAAAAyfAU+PAAAA4PAAADdAj+PAAAAAAAAADxA28P//PAAAAAAmvAv6P8/PA8PAAAQJAw+P0/PAAAAAA9GAi+P4/PA4PAAAbEA9+P3/PAAAAAAhCA9+Pw/PAAAAAA1AAL/Pn/PAAAAAAAAAl/PZ/PAAAAAA69PAAAF/PAAAAAA
        EB+Aj
        LBPtAAAAAA*+EIAAAAg+AAAAoABAAAICB+
        LBPtAAAAAAP+FAAAAoABAAAg/AHAAAAAAAAAyCBAAAAAAAAAg/A
        LBPtAAAAAAS+DAjBAAoZmS0QAA4MzFIRt9PAsBAYNJBAB/PQAAAAAAAAAAAAAAIAAAAAAAAAAAAAADAAAAAAAAAAAAAABAAAAAAAAAAAAAACAAAAAAAAAAAAAALAAAAAAAAAAAAAAEAAAAAAAAoAAbkPDAAAAAAAANAAUyPCAAAAAAAAAAALvPCAAAAAAAAAAAKrPCAAAAAAEAi+P9mPCAAAAAAAAmzPkbOBAAAAAAAAU6PNYPDAAAAAAIA65PiWPAAAAAAAEAU6PhWPAAAAAAAAAm7PYXPAAAAAAAEAD9PEZPAAAAAAAAA9+PYbPAAAAAAAIAAAA6dPAAAAAAAAAsBA8CPAAAAAAAAAUCAflPAAAAAAAEAhCAAoPAAAAAAAAAGCAhqPAAAAAAAIAHCA3sPAAAAAAAAA4BAKvPAAAAAAAAAeBAexPAAAAAAAEAeBAYzPAAAAAAAAAQBAs1P//PAAAAAAXDA6tP+/PAAAAAADBAAAAu/PAAAAEAQBAhCA0/PAAAAAA2AAXDAq/PAAAAAAQBAGKAE/PAAAAAA
        EB+Dj
    ";

    // Run the edits
    let mut animation = create_animation();
    perform_serialized_edits(&mut animation, edits);

    // Animation should contain a single layer and a frame with a single grouped item in it
    let layer       = animation.get_layer_with_id(1).unwrap();
    let frame       = layer.get_frame_at_time(Duration::from_millis(0));
    let elements    = frame.vector_elements().unwrap().collect::<Vec<_>>();

    assert!(elements.len() == 1);

    let group = match elements[0] {
        Vector::Group(ref group)    => Some(group.clone()),
        _                           => None
    }.expect("Element should be a group");

    assert!(group.group_type() == GroupType::Added);
    assert!(group.elements().count() == 2);
}

#[test]
fn collide_three_paths_by_adding_to_existing_collision() {
    // Collide two paths then add an extra one to the collision
    let edits = "
        +B
        LB+tAAAAAA
        LBPtAAAAAA*+EIAAAAg+AAAAoABAAAICB+
        LBPtAAAAAAP+FAAAAoABAAAg/AHAAAAAAAAAyCBAAAAAAAAAg/A
        LBPtAAAAAAS+DAoBAAoZmBwQAAoZGMIRa8PAACA4N8BAL/PRBAAAAAAAAAAAAAKAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAADAAAAAAAAAAAAAAEAAAAAAAAAAAAAAEAAAAAAAAaAAslPCAAAAAAAAAAAA0PCAAAAAAIAAAA5xPDAAAAAAAAI+PbEPDAAAAAAAAs9PslPKAAAAAAEA28P5hPCAAAAAAAAc8PwePBAAAAAAAAA8PAcPBAAAAAAEAm7PeZPBAAAAAAAAK7PzXPAAAAAAAAAL7PvWPAAAAAAAIAEtPJbNAAAAAAAAAO8PVaPAAAAAAAMAp8PpcPAAAAAAAAAD9PXfPAAAAAAAEAf9PviPAAAAAAAAAs9PslPAAAAAAAEA59P2oPAAAAAAAAAL7PsJPAAAAAAAIAw+PiyPAAAAAAAAAZ/P10PAAAAAAAEAl/P+2PAAAAAAAAAz/Po4P//PAAAAAAz/Pj6P//PAAAAAAAAAO8P+/PAAAAIAAAAr9P9/PAAAAAAAAAHGA8/PAAAAAAAAAuGAL/PAAAAAAAAAsFAf/PAAAAAAAAADNAD/PAAAAAA
        EB+Dj
        LBPtAAAAAA*+HIAAAAg+AAAAoABAAAICB+
        LBPtAAAAAAP+IAAAAoABAAAg/AHAAAAAAAAAyCBAAAAAAAAAg/A
        LBPtAAAAAAS+GAiBNnEAAomZyHRl9PAMCAAO6AAS9PNAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9/PAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeVA0/PGAAAAAAAApIAaAAOAAAAAAAATKA2AAFAAAAAAAApMADBAEAAA8PAAA8OArBACAAAAAAAACRA5BADAAAAAAAA8SAUCACAAAAAAAAoUAhCACAAA4PAAAStARFACAAAAAAAAoYAhCAEAAAAAAAAeZAGCACAAA8PAAAvaA5BABAAAAAAAAlbAeBAAAAAAAAAAOcAQBAAAAAAAAAApcA1AAAAAAAAAAA1cAbAAAAAA8PAAA1cAaAAAAAAAAAAARRBNAAAAAAAAAAAKXAAAAAAAA4PAAAoUA9+P+/PAAAAAA5RAU+P9/PAAAAAAKPAV+P9/PA8PAEACNAH+P8/PAAAAAA9KAU+P5/PAAAAAARJAV+P2/PAAAAAAXHAH+Pu/PAAAAAADFAi+Ph/PAAAAAAXDAI+P7+PAAAAAA
        EB+Gj
        LBPtAAAAAAS+JAhBAkDAAYzs6FRC9PAACAgO9AAf9PmAAAAAAAAAAAAAALAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAFAAAAAAAAAAAAAAEAAAAAAAAAAAAAADAAAAAAAAvOAHSADAAAAAAAA1IAhCAGAAAAAAAAAYARFACAAAAAAAAXPAuCAGAAAAAAAAeRA9CADAAAAAAAANUA9CADAAAAAAAAUWAJDADAAAAAAAApYAYDACAAA8PAAAvaAkDABAAAAAAAAU6AvGABAAAAAAAAXfA7CACAAA8PAAAOgAhCAAAAAAAAAADhAHCAAAAAAAAAArhAdBAAAAAAAAAARhAQBAAAAAAAAAAbgAoAAAAAA4PAAA8eAAAAAAAAAAAAAbcAAAAAAAAAAAAAzDBL/P//PAAAAAAeRAK/Pz/PA8PAAAlPAZ/P4/PAAAAAAHOAl/P3/PA4PAAA1MAAAAw/PAAAAAADJAAAAO/PAAAAAA
        EB+Jj
    ";

    // Run the edits
    let mut animation = create_animation();
    perform_serialized_edits(&mut animation, edits);

    // Animation should contain a single layer and a frame with a single grouped item in it
    let layer       = animation.get_layer_with_id(1).unwrap();
    let frame       = layer.get_frame_at_time(Duration::from_millis(0));
    let elements    = frame.vector_elements().unwrap().collect::<Vec<_>>();

    assert!(elements.len() == 1);

    let group = match elements[0] {
        Vector::Group(ref group)    => Some(group.clone()),
        _                           => None
    }.expect("Element should be a group");

    assert!(group.group_type() == GroupType::Added);
    assert!(group.elements().count() == 3);
}

#[test]
fn collide_three_paths_all_at_once() {
    // Draw two lines and join them to make an 'H' (which should all collide into one)
    let two_lines = "
        +B
        LB+tAAAAAA
        LBPtAAAAAA*+BIAAAAg+AAAAoABAAAICB+
        LBPtAAAAAAP+CAAAAoABAAAg/AHAAAAAAAAAyCBAAAAAAAAAg/A
        LBPtAAAAAAS+AAsBaqFAAoZOEIRN9PAMCAAONDA4AAcAAAAAAAAAAAAAAKAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAFAAAAAAAAAAAAAAHAAAAAAAAAAAAAAFAAAAAAAAnAAUqPEAAAAAAAA9+PUmPCAAAAAAAA69PYvPEAAAAAAEAf9PEtPCAAAAAAAA28PiqPCAAAAAAAA38PcoPCAAAAAAAA28PHmPCAAAAAAAAD9PAkPCAAAAAAEAF9PiiPBAAAAAAAAU6PcAPAAAAAAAAAR9PhePBAAAAAAIAR9PRdPAAAAAAAAAS9P2cPAAAAAAAEAD9PbcPAAAAAAAAAD9PbcPAAAAAAAAAF9PDdPAAAAAAAAAD9P6dPAAAAAAAIAD9P9ePAAAAAAAAAv6PAEPAAAAAAAAAs9PElPAAAAAAAEA69PKnPAAAAAAAEAz7PzTPAAAAAAAAA69PbsPAAAAAAAIA59PVuPAAAAAAAAAV+PBwPAAAAAAAAAU+P5xP//PA8PAAA69PRpP//PAAAAEAl/PpwP9/PAAAAAAAAA96P4/PAAAAIAAAAp8P4/PAAAAAA1AAU+P0/PAAAAAA5BAAAAs/PAAAAAAsBAAAAa/PAAAAAAJDAeFA3+PAAAAAA
        EB+Aj
        LBPtAAAAAA*+EIAAAAg+AAAAoABAAAICB+
        LBPtAAAAAAP+FAAAAoABAAAg/AHAAAAAAAAAyCBAAAAAAAAAg/A
        LBPtAAAAAAS+DAnBAAYzMgzQAAIAg0HR48PAACAEOYDAX+PlAAAAAAAAAAAAAALAAAAAAAAAAAAAACAAAAAAAAAAAAAADAAAAAAAAAAAAAAGAAAAAAAAAAAAAAKAAAAAAAAAAAAAAIAAAAAAAAAAAAAAFAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//PAAAAAAoAAw+PAAAAAAAAANAAi6PDAAAAAAAAMAAB4PDAAAAAAAAAAAKnPDAAAAAAAAAAA8uPEAAAAAAAA9+PBsPBAAAAAAEAV+PRpPBAAAAAAAAf9P6lPBAAAAAAAA28P9iPCAAAAAAAAO8PlfPBAAAAAAIAz7P2cPBAAAAAAAAY3PyzOBAAAAAAEAm3P4xOBAAAAAAAAO8PiaPAAAAAAAIAc8PNcPAAAAAAAAAR9PhePAAAAAAAEAR9P3gPAAAAAAAAA69PXjPAAAAAAAEAH+P6lPAAAAAAAAAi6P4tOAAAAAAAAAL/PExP+/PAAAAIAL/PKzPAAAAAAAEAK/Pf1P//PAAAAAAZ/PJ3P//PAAAAAAl/Ps5P+/PAAAAAAm/P07P+/PAAAAIAl/PCRA8/PAAAAAA
        EB+Dj
    ";
    let join_lines = "
        LBPtAAAAAAS+GAiBYtCAA4QggGRZ8PAICAQOAAAOBATBAAAAAAAAAAAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+/PAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAHAAAAAAAAbYAz/PGAAAAAAAA1IAAAADAAAAAAAAhKAAAAEAAAAAAAAoMAAAADAAAAAAAABcB5BACAAAAAAAANYANAALAAA4PAAAUaAAAABAAAAAAAAAcAAAAAAAAAAAAAsdAMAAAAAAAAAAAXfANAAAAAA8PAAAtxCAAAAAAAAAAAADlAAAABAAA8PAEAAkAAAAAAAAAAAAA5hAAAAAAAA4PAAAyfAAAAAAAAAAAAABoBL7PAAAAAAAAAEVAL/PAAAA8PAAAXTAY/PAAAAAAAAAfRAz/P//PAAAAAAyPAAAA//PAAAAAAHOAAAAAAAAAAAAAOMAAAA//PAAAAAAGKAbAA//PAAAAAAGWAeBA+/PAAAAAANAAAAAL/PAAAAAAAAAAAAW/PAAAAAA
        EB+Gj
    ";

    // The two lines on either side of the 'H'
    let mut animation = create_animation();
    perform_serialized_edits(&mut animation, two_lines);

    // Animation should contain a single layer and a frame with a single grouped item in it
    let layer       = animation.get_layer_with_id(1).unwrap();
    let frame       = layer.get_frame_at_time(Duration::from_millis(0));
    let elements    = frame.vector_elements().unwrap().collect::<Vec<_>>();

    // These don't join together
    assert!(elements.len() == 2);

    // The cross line that forms the 'H' shape
    perform_serialized_edits(&mut animation, join_lines);

    let layer       = animation.get_layer_with_id(1).unwrap();
    let frame       = layer.get_frame_at_time(Duration::from_millis(0));
    let elements    = frame.vector_elements().unwrap().collect::<Vec<_>>();

    // Everything joined into one element now
    assert!(elements.len() == 1);

    let group = match elements[0] {
        Vector::Group(ref group)    => Some(group.clone()),
        _                           => None
    }.expect("Element should be a group");

    assert!(group.group_type() == GroupType::Added);
    assert!(group.elements().count() == 3);
}

#[test]
fn join_two_groups() {
    // Draw two plus signs then join them into a single path
    let two_plus_signs = "
        +B
        LB+tAAAAAA
        LBPtAAAAAA*+BIAAAAg+AAAAoABAAAICB+
        LBPtAAAAAAP+CAAAAoABAAAg/AHAAAAAAAAAyCBAAAAAAAAAg/A
        LBPtAAAAAAS+AArBmDGAAIAYHIRa9PAMCAEOtDA6/PTAAAAAAAAAAAAAAGAAAAAAAAAAAAAAEAAAAAAAAAAAAAAFAAAAAAAAAAAAAAQAAAAAAEAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAHCA9+PAAAAAAAAAnAAc8PCAAAAAAAAoAAL7PCAAAAAAAAQBAvyPCAAAAAAAANAAy3PDAAAAAAIAAAAj2PBAAAAAAAAAAAR1PBAAAAAAAAAAAzzPBAAAAAAAAAAAVyPCAAAAAAAAK/P2wPCAAAAAAAAw+PKvPBAAAAAAEAi+PetPBAAAAAAAAI6Pl/OAAAAAAAAAf9POoPBAAAAAAAAf9PAoPAAAAAAAAAD9PznPAAAAAAAAAR9PznPAAAAAAAIAF9PAoPAAAAAAAAAR9PboPAAAAAAAAAR9PpoPAAAAAAAAAs9PepPAAAAAAAEAO4PU2OAAAAAAAAAw+PHyPAAAAAAAEAw+PmzPAAAAAAAAAL/Pp0PAAAA8PAAAY/PH2PAAAAAAAAAm/PY3PAAAAAAAAAAAA9yPAAAAAAAAAAAAY7P+/PAAAAAAAAAD9P+/PAAAAAArBAU+P9/PAAAAAAQBAAAAx/PAAAAAAeBAKDAv/PAAAAAAQBAXDAa/PAAAAAAQBAGKAr+PAAAAAA
        EB+Aj
        LBPtAAAAAA*+EIAAAAg+AAAAoABAAAICB+
        LBPtAAAAAAP+FAAAAoABAAAg/AHAAAAAAAAAyCBAAAAAAAAAg/A
        LBPtAAAAAAS+DAoB0LCAAoZ2RHR/8PAMCAQOIBAX9PpAAAAAAAAAAAAAAOAAAAAAAAAAAAAAFAAAAAAAAAAAAAACAAAAAAAAAAAAAADAAAAAAAAAAAAAAEAAAAAAAAAAAAAADAAAAAAAAAAAAAACAAAAAAAAAAAAAAKAAA8PAAAsZAs9PCAAAAAAAAlHA8+PCAAAAAAAAoIAL/PCAAAAAAAAGKAZ/PDAAAAAAAAs5AMAACAAAAAAAA8SA5BAGAAAAAAAAoUAhCABAAAAAAAAHWAvCAAAAAAAAAAJXAJDAAAAAAAAAAAYAKDAAAAA4PAAA2YA7CAAAAAAAAAA6xAEFAAAAAAAAAAMYA4BAAAAA8PAAAYXADBAAAAAAAAAAeVAoAAAAAAAAAAAzTAAAA//PAAAAAArRAAAA//PAAAAAAXPAY/P//PAAAAAAQNAi+P//PAAAAAAKLAI+P//PAAAAAAOQAz7P//PAAAAAAdFA69P8/PAAAAAANEAU+P9/PAAAAAA9CAU+P8/PAAAAAAGCAw+P5/PAAAAAA5BAw+P2/PAAAAAArBAL/Py/PAAAAAADBAl/Pn/PAAAAAA2AA0/PU/PAAAAAAAAAAAAP/PAAAAAA
        EB+Dj
        LBPtAAAAAAS+GAlBAAYzM00QAA4MTyFRG9PAMCAAOnDAB+PhAAAAAAAAAAAAAALAAAAAAAAAAAAAAFAAAAAAAAAAAAAAFAAAAAAAAAAAAAAHAAAAAAAAAAAAAAHAAAAAAAAAAAAAAFAAAAAAAAAAAAAADAAAAAAAAUCAm3PAAAAAAAAAAAAy3PFAAAAAAAAAAAe1PCAAAAAAEAAAA+yPCAAAAAAAAz/P2wPBAAAAAAAAw+PhuPBAAAAAAAAw+PBsPCAAAAAAEAp8P2QPBAAAAAAAAH+PDlPCAAAAAAAA69PYjPAAAAAAAIA69PUiPAAAAAAAAA59PiiPAAAAAAAAAI+PmjPAAAAAAAAAi+PflPAAAAAAAEA9+PNoPAAAAAAAAAz/P9qPAAAAAAAAAAAA5tPAAAAAAAAAAAAcwPAAAAAAAIAoAAznPAAAAAAAAA1AAL3PAAAAAAAAA1AAR5PAAAAAAAAA2AAL7P//PAAAAEADBAR9P+/PAAAAAA1AAi+P7/PAAAAAA5BAAAA5/PAAAAAAnAAXDAq/PAAAAAAAAARFAq/PAAAAAAAAApEAW+PAAAAAA
        EB+Gj
        LBPtAAAAAAS+HAkBAAomZmxQAA4MTzERU9PAMCAIO8AAk9PXAAAAAAAAAAAAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAGAAAAAAAAAAAAAAHAAAAAAAAAAAAAAFAAAAAAAAAYAY/PEAAAAAAAAERA5BADAAAAAAAAhKA4BAEAAAAAAAAAMAUCACAAAAAAAAeNAhCACAAAAAAAA9OA9CABAAAAAAAAoQA9CABAAAAAAAAGSAJDACAAAAAAAAzTAYDABAAA8PAAAVCB5JAAAAAAAAAAAYAXDABAAA4PAAAaYAXDAAAAAAAAAA2YAKDAAAAAAAAAAoYA9CAAAAAAAAAABYAUCAAAAAAAAAAhWAQBAAAAAAAAAAoUAbAAAAAAAAAAAK7AX7PAAAAAAAIARJAs9P//PAAAAAAXHAs9PAAAAAAAAA4FAs9P//PAAAAAAbEAr9P//PAAAAAAkDA69P+/PAAAAAAoEAm7P+/PAAAAAAAAAY/Pw/PAAAAAAAAAAAAW/PAAAAAAR9PNAA++PAAAAAA
        EB+Hj
    ";

    let join_plus_signs = "
        LBPtAAAAAAS+IAvDasDAAYzsDIRB9PAICAIOCCAr8PqAAAAAAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//PAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAHAAAAAAIAAAAAAAFAAAAAAAAeZAOkPKAAAAAAAArFA55PDAAAAAAAAGGAg5PCAAAAAAAAhGAf5PCAAAAAAAA9GA24PCAAAAAAAAXHAp4PCAAAAAAAA/PApwPBAAAAAAAAljANcPDAAAAAAAARJAt1PDAAA4PAAArJAR1PAAAAAAAAA6JAp0PAAAAAAAAAGKAA0PAAAA8PAAAUKAzzPAAAAAAAEAuKAYzPAAAAAAAAAKLAKzPAAAAAAAAA8WAHmPAAAA8PAAAAMALzPAAAAAAAAANMAlzPAAAAAAAAAOMAB0PAAAAAAAAANMAb0PAAAA4PAIAAMA20PAAAAAAAAAJXAiqPAAAAAAAAAXLAe1PAAAAAAAEAeVAiqPAAAAAAAAAsJAe1PAAAAAAAAADJAs1PAAAAAAAAANIA61PAAAAAAAAAyHAe1PAAAAAAAAAJHAf1PAAAAAAAAALnAbEPAAAAAAAEADJAKzPDAAAAAAAAdJAKzPAAAAAAAAArJAmzPAAAAAAAAAUKAlzPAAAAAAAAAUKAB0PAAAAAAAAAiKAO0PAAAA8PAAADVAEpPAAAAAAAIAGKAp0PAAAAAAAAA6JAp0PAAAAAAAAArJAb0PAAAAAAAAAeJA20PAAAAAAAEAQJAD1PAAAAAAAAADJAt1PAAAAAAAAADJAG2PAAAAAAAAADJAj2PAAAA4PAAA1IA92PAAAAAAAIA5ZAslPAAAAAAAAAaIAX3PBAAAAAAAAaIAm3PAAAAAAAAAAIAz3PAAAA8PAEAyHAy3PAAAAAAAAAXHAA4PAAAAAAAAA9GAO4PAAAAAAAAA1MASxPAAAAAAAAA6FA34PAAAAAAAIA4FAR5PAAAAAAAAA6FA34PAAAAAAAAA4FA24PAAAAAAAAA4FA34PAAAAAAAAA6FA24PAAAAAAAAA4FA34PAAAAAAAAA4FA34PAAAAAAAAA6FAR5PAAAAAAAAA4FAR5PAAAAAAAEA2QAHuPAAAAAAAAADFAV6PAAAAAAAAADFAi6PAAAAAAAAAoEAj6PAAAAAAAAAbEAv6PAAAAAAAAA/HA61PAAAAAAAAAyDAK7PAAAAAAAAAYDAL7PAAAAAAAAAXDA96PAAAAAAAAAkDAL7PAAAAAAAAAkDA96PAAAAAAAAAAEA96PAAAAAAAAANEA96PAAAAAAAAAbEA96PAAAAAAAAAoEAv6PAAAAAAAEACRABwPAAAAAAAAAfNAe1PAAAAAAAAA8GA96PAAAAAAAAA9GAY7PAAAAAAAIAvGAl7PAAAAAAAAAuGAz7PAAAA4PAAAUGAO8PAAAAAAAAA6FAO8PAAAAAAAAAdFAc8PAAAAAAAAA2EAp8PAAAAAAAAAMEA28PAAAAAAAAAKDAR9PAAAAAAAAAhCAs9PAAAAAAAEArBA69P//PAAAAAA2AAw+P//PAAAAAAaAA9+P+/PAAAAAAAAAl/P+/PAAAAAAAAAAAA9/PAAAAAAAAAAAA7/PAAAAAAm/PAAA2/PAAAAAAi+PNAAs/PA8PAAAw+PnAAF/PAAAAAAp8PbAAz+PAAAAAA
        EB+Ij
    ";

    // Draw two plus signs
    let mut animation = create_animation();
    perform_serialized_edits(&mut animation, two_plus_signs);

    // Animation should contain a single layer and a frame with a two grouped items in it
    let layer       = animation.get_layer_with_id(1).unwrap();
    let frame       = layer.get_frame_at_time(Duration::from_millis(0));
    let elements    = frame.vector_elements().unwrap().collect::<Vec<_>>();

    // These don't join together
    assert!(elements.len() == 2);

    // Join the two plus signs into a single grouped shape
    perform_serialized_edits(&mut animation, join_plus_signs);

    let layer       = animation.get_layer_with_id(1).unwrap();
    let frame       = layer.get_frame_at_time(Duration::from_millis(0));
    let elements    = frame.vector_elements().unwrap().collect::<Vec<_>>();

    // Everything joined into one element now
    assert!(elements.len() == 1);

    let group = match elements[0] {
        Vector::Group(ref group)    => Some(group.clone()),
        _                           => None
    }.expect("Element should be a group");

    assert!(group.group_type() == GroupType::Added);
    assert!(group.elements().count() == 5);
}
