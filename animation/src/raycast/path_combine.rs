use flo_curves::*;
use flo_curves::bezier::*;
use flo_curves::bezier::path::*;

///
/// Computes the bounding box of a set of paths
///
#[inline]
fn get_bounds<P: BezierPath>(path: &Vec<P>) -> Bounds<P::Point> {
    path.iter()
        .map(|path| path.bounding_box::<Bounds<_>>())
        .fold(Bounds::empty(), |a, b| a.union_bounds(b))
}

///
/// If two paths can be combined, returns the combined paths. Paths can be combined if they collide at any point.
///
/// The path that is passed in here must have no interior points: these can be removed by `path_remove_overlapped_points`
/// if necessary.
///
pub fn combine_paths<P: BezierPathFactory>(path1: &Vec<P>, path2: &Vec<P>, accuracy: f64) -> Option<GraphPath<P::Point, PathLabel>>
where P::Point: Coordinate2D {
    // Nothing to combine if either of the paths are empty
    if path1.len() == 0 || path2.len() == 0 {
        return None;
    }

    // Paths do not overlap if their bounding boxes do not overlap
    let bounds1 = get_bounds(path1);
    let bounds2 = get_bounds(path2);

    if !bounds1.overlaps(&bounds2) {
        // Neither of the paths overlap as the bounding boxes are different
        None
    } else {
        // Convert both to graph paths
        let graph_path1 = GraphPath::from_merged_paths(path1.iter().map(|path| (path, PathLabel(0, PathDirection::from(path)))));
        let graph_path2 = GraphPath::from_merged_paths(path2.iter().map(|path| (path, PathLabel(1, PathDirection::from(path)))));

        match graph_path1.collide_or_merge(graph_path2, accuracy) {
            CollidedGraphPath::Collided(collided_path)  => Some(collided_path),
            CollidedGraphPath::Merged(merged_path)      => if merged_paths_overlap(&path1, &path2, &merged_path) { Some(merged_path) } else { None }
        }
    }
}

///
/// Determines if a graph path generated by merging two paths has an overlap in it
///
fn merged_paths_overlap<P: BezierPath>(path1: &Vec<P>, path2: &Vec<P>, merged_path: &GraphPath<P::Point, PathLabel>) -> bool
where P::Point: Coordinate2D {
    // The paths overlap if there is any ray cast at an edge in path1 or path2 that crosses both paths. We only need to cast one ray per path (as we know neither path crosses each other)
    // (annoyingly this means that finding paths that do not overlap is much more expensive than finding ones that do)
    for path in path1.iter().chain(path2.iter()) {
        // Fetch an edge from the path
        let start_point = path.start_point();
        let edge        = path.points().nth(0);

        if let Some((cp1, cp2, end_point)) = edge {
            let edge    = Curve::from_points(start_point, (cp1, cp2), end_point);

            // Cast a ray at the center of the edge
            let target          = edge.point_at_pos(0.5);
            let normal          = edge.normal_at_pos(0.5);
            let ray             = (target, target+normal);
            let collisions      = merged_path.ray_collisions(&ray);
            let ray_direction   = ray.1-ray.0;

            // Count crossings: if there's any point where both are non-zero we've got an overlap
            let mut crossings   = [0,0];

            for (collision, curve_t, _line_t, _position) in collisions {
                // Work out which direction we're crossing in
                let edge                                = collision.edge();
                let PathLabel(path_number, direction)   = merged_path.edge_label(edge);
                let normal                              = merged_path.get_edge(edge).normal_at_pos(curve_t);

                let side                                = ray_direction.dot(&normal).signum() as i32;
                let side                                = match direction {
                    PathDirection::Clockwise        => { side },
                    PathDirection::Anticlockwise    => { -side }
                };

                // Add to the crossing count for this path (we assume the path numbers are 0 or 1 here)
                crossings[path_number as usize] += side;

                // If we're inside both paths here then the paths overlap
                if crossings[0]&1 != 0 && crossings[1]&1 != 0 {
                    return true;
                }
            }
        }
    }

    // Paths do not overlap
    false
}

#[cfg(test)]
mod test {
    use super::*;
    use flo_curves::arc::*;

    #[test]
    fn colliding_paths_combine() {
        // Two circles that overlap
        let circle1 = Circle::new(Coord2(2.0, 2.0), 2.0).to_path::<SimpleBezierPath>();
        let circle2 = Circle::new(Coord2(3.0, 2.0), 2.0).to_path::<SimpleBezierPath>();

        // These two should combine
        let combined = combine_paths(&vec![circle1], &vec![circle2], 0.01);
        assert!(combined.is_some());
    }

    #[test]
    fn non_overlapping_circles_outside_bounds_do_not_combine() {
        // Two circles that are far apart
        let circle1 = Circle::new(Coord2(2.0, 2.0), 2.0).to_path::<SimpleBezierPath>();
        let circle2 = Circle::new(Coord2(20.0, 2.0), 2.0).to_path::<SimpleBezierPath>();

        // These two should combine
        let combined = combine_paths(&vec![circle1], &vec![circle2], 0.01);
        assert!(combined.is_none());
    }

    #[test]
    fn non_overlapping_circles_inside_each_others_bounds_do_not_combine() {
        // Two circles that overlap in bounding boxes but not as paths
        let circle1 = Circle::new(Coord2(2.0, 2.0), 2.0).to_path::<SimpleBezierPath>();
        let circle2 = Circle::new(Coord2(5.6, 5.6), 2.0).to_path::<SimpleBezierPath>();

        // These two should combine
        let combined = combine_paths(&vec![circle1], &vec![circle2], 0.01);
        assert!(combined.is_none());
    }

    #[test]
    fn circle_in_circle_does_combine() {
        // One circle inside another (these will not generate any collisions but as they overlap, we should get an overlapping circle)
        let circle1 = Circle::new(Coord2(2.0, 2.0), 2.0).to_path::<SimpleBezierPath>();
        let circle2 = Circle::new(Coord2(2.0, 2.0), 1.0).to_path::<SimpleBezierPath>();

        // These two should combine
        let combined = combine_paths(&vec![circle1], &vec![circle2], 0.01);
        assert!(combined.is_some());
    }

    #[test]
    fn circle_in_circle_does_combine_reverse() {
        // One circle inside another (these will not generate any collisions but as they overlap, we should get an overlapping circle)
        let circle1 = Circle::new(Coord2(2.0, 2.0), 2.0).to_path::<SimpleBezierPath>();
        let circle2 = Circle::new(Coord2(2.0, 2.0), 1.0).to_path::<SimpleBezierPath>();

        // These two should combine
        let combined = combine_paths(&vec![circle2], &vec![circle1], 0.01);
        assert!(combined.is_some());
    }

    #[test]
    fn remove_overlapped_for_ring_removes_nothing() {
        let ring1   = Circle::new(Coord2(2.0, 2.0), 2.0).to_path::<SimpleBezierPath>();
        let ring2   = Circle::new(Coord2(2.0, 2.0), 1.5).to_path::<SimpleBezierPath>();

        let removed = path_remove_overlapped_points::<_, SimpleBezierPath>(&vec![ring1.clone(), ring2.clone()], 0.01);

        assert!(removed.len() == 2);
    }

    #[test]
    fn circle_in_ring_does_not_combine() {
        // A ring has a hole in it so a circle in that hole does not actually overlap it
        let ring1   = Circle::new(Coord2(2.0, 2.0), 2.0).to_path::<SimpleBezierPath>();
        let ring2   = Circle::new(Coord2(2.0, 2.0), 1.5).to_path::<SimpleBezierPath>();
        let circle2 = Circle::new(Coord2(2.0, 2.0), 1.0).to_path::<SimpleBezierPath>();

        // These two should not combine
        let combined = combine_paths(&vec![ring1, ring2], &vec![circle2], 0.01);
        assert!(combined.is_none());
    }

    #[test]
    fn circle_in_ring_does_not_combine_reverse() {
        // A ring has a hole in it so a circle in that hole does not actually overlap it
        let ring1   = Circle::new(Coord2(2.0, 2.0), 2.0).to_path::<SimpleBezierPath>();
        let ring2   = Circle::new(Coord2(2.0, 2.0), 1.5).to_path::<SimpleBezierPath>();
        let circle2 = Circle::new(Coord2(2.0, 2.0), 1.0).to_path::<SimpleBezierPath>();

        // These two should not combine
        let combined = combine_paths(&vec![circle2], &vec![ring1, ring2], 0.01);
        assert!(combined.is_none());
    }
}
