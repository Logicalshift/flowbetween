use flo_curves::*;
use flo_curves::bezier::*;
use flo_curves::bezier::path::*;

///
/// Computes the bounding box of a set of paths
///
#[inline]
fn get_bounds<P: BezierPath>(path: &Vec<P>) -> Bounds<P::Point> {
    path.iter()
        .map(|path| path.bounding_box::<Bounds<_>>())
        .fold(Bounds::empty(), |a, b| a.union_bounds(b))
}

///
/// If two paths can be combined, generates the 
///
pub fn combine_paths<P: BezierPath>(path1: &Vec<P>, path2: &Vec<P>, accuracy: f64) -> Option<GraphPath<P::Point, PathLabel>>
where P::Point: Coordinate2D {
    // Nothing to combine if h
    if path1.len() == 0 || path2.len() == 0 {
        return None;
    }

    // Paths do not overlap if their bounding boxes do not overlap
    let bounds1 = get_bounds(path1);
    let bounds2 = get_bounds(path2);

    if !bounds1.overlaps(&bounds2) {
        // Neither of the paths overlap as the bounding boxes are different
        None
    } else {
        // Convert both to graph paths
        let graph_path1 = GraphPath::from_merged_paths(path1.into_iter().map(|path| (path, PathLabel(0, PathDirection::from(path)))));
        let graph_path2 = GraphPath::from_merged_paths(path2.into_iter().map(|path| (path, PathLabel(1, PathDirection::from(path)))));

        match graph_path1.collide_or_merge(graph_path2, accuracy) {
            CollidedGraphPath::Collided(collided_path)  => Some(collided_path),
            CollidedGraphPath::Merged(merged_path)      => if merged_paths_overlap(path1, path2, &merged_path) { Some(merged_path) } else { None } 
        }
    }
}

///
/// Determines if a graph path generated by merging two paths has an overlap in it
///
fn merged_paths_overlap<P: BezierPath>(path1: &Vec<P>, path2: &Vec<P>, merged_path: &GraphPath<P::Point, PathLabel>) -> bool 
where P::Point: Coordinate2D {
    // The paths overlap if there is any ray cast at an edge in path1 or path2 that crosses both paths. We only need to cast one ray per path (as we know neither path crosses each other)
    // (annoyingly this means that finding paths that do not overlap is much more expensive than finding ones that do)
    for path in path1.iter().chain(path2.iter()) {
        // Fetch an edge from the path
        let start_point = path.start_point();
        let edge        = path.points().nth(0);

        if let Some((cp1, cp2, end_point)) = edge {
            let edge    = Curve::from_points(start_point, (cp1, cp2), end_point);

            // Cast a ray at the center of the edge
            let target          = edge.point_at_pos(0.5);
            let normal          = edge.normal_at_pos(0.5);
            let ray             = (target, target+normal);
            let collisions      = merged_path.ray_collisions(&ray);
            let ray_direction   = ray.1-ray.0;

            // Count crossings: if there's any point where both are non-zero we've got an overlap
            let mut crossings   = [0,0];

            for (collision, curve_t, _line_t, _position) in collisions {
                // Work out which direction we're crossing in
                let edge                                = collision.edge();
                let PathLabel(path_number, direction)   = merged_path.edge_label(edge);
                let normal                              = merged_path.get_edge(edge).normal_at_pos(curve_t);

                let side                                = ray_direction.dot(&normal).signum() as i32;
                let side                                = match direction {
                    PathDirection::Clockwise        => { side },
                    PathDirection::Anticlockwise    => { -side }
                };

                // Add to the crossing count for this path (we assume the path numbers are 0 or 1 here)
                crossings[path_number as usize] += side;

                // If we're inside both paths here then the paths overlap
                if crossings[0] != 0 && crossings[1] != 0 {
                    return true;
                }
            }
        }
    }

    // Paths do not overlap
    false
}
