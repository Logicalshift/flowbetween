use super::control_id::*;
use super::focus::*;

use flo_scene::*;
use flo_scene::programs::*;
use flo_draw::*;

use futures::prelude::*;
use serde::*;

/// Distance that a control is 'pulled' before it starts being dragged
const PULL_DISTANCE: f64 = 32.0;

///
/// Messages generated by the 'gesture' program that let us track actions performed by the user
///
#[derive(Clone, Debug, PartialEq)]
#[derive(Serialize, Deserialize)]
pub enum Gesture {
    /// General focus event that isn't used with a gesture
    Focus(FocusEvent),

    /// User has pressed the mouse down, starting an action interacting with a control
    Preselect(Option<ControlId>, PointerState),

    /// User has cancelled the action associated with a control (eg, by pressing escape while the button is down)
    CancelAction(Option<ControlId>, PointerState),

    /// User has released the mouse button over a control, making it selected
    Select(Option<ControlId>, PointerState),

    /// User is starting to drag the control but it has not 'detached' from its original position yet. The coordinates here are the offset from the control's original position
    Pull(Option<ControlId>, PointerState, (f64, f64)),

    /// User is dragging the control, with the specified position as the target
    Drag(Option<ControlId>, PointerState, (f64, f64)),

    /// User has dropped the control at the specified location
    Drop(Option<ControlId>, PointerState, (f64, f64)),
}

///
/// Runs a gesture program, forwarding any focus events originally destined for the current program to the new program
///
pub async fn run_gesture_program(context: &SceneContext) {
    let active_program_id  = context.current_program_id().unwrap();
    let gesture_program_id = SubProgramId::new();

    let mut scene_control = context.send(()).unwrap();
    
    // Run the gesture program
    scene_control.send(SceneControl::start_child_program(gesture_program_id, active_program_id, move |input, context| {
        gesture_program(input, context)
    }, 1)).await.ok();

    // Send messages from the gesture program back to the original program
    scene_control.send(SceneControl::connect(gesture_program_id, active_program_id, StreamId::with_message_type::<Gesture>())).await.ok();

    // Redirect messages intended for the source program to the gesture program
    scene_control.send(SceneControl::connect((), gesture_program_id, StreamId::with_message_type::<FocusEvent>().for_target(active_program_id))).await.ok();
}

///
/// The gesture program takes focus events and converts them to more interesting gesture events (like drags, drops, etc)
///
/// Unrecognised focus events are passed on.
///
/// Create the subprogram when the mouse down event is detected, then forward any focus events here
///
pub async fn gesture_program(input: InputStream<FocusEvent>, context: SceneContext) {
    // We'll forward unhandled focus events back to the main program
    // TODO: think this ends up sending them back to us...
    let mut forward_gesture = context.send(()).ok();

    // Nothing to do if we fail to connect to both the focus and gesture events
    if forward_gesture.is_none() {
        return;
    }

    // Run the main event loop
    let mut input = input;
    while let Some(evt) = input.next().await {
        match evt {
            FocusEvent::Event(control_id, DrawEvent::Pointer(PointerAction::ButtonDown, pointer_id, pointer_state)) => {
                // Gestures are started with a mouse down event
                if let Some(gestures) = &mut forward_gesture {
                    track_button_down(&mut input, &context, control_id, pointer_id, pointer_state, gestures).await;
                }
            }

            other => {
                // Other types of events are just forwarded immediately
                if let Some(gestures) = &mut forward_gesture {
                    if gestures.send(Gesture::Focus(other)).await.is_err() {
                        forward_gesture = None;
                    }
                }
            }
        }

        if forward_gesture.is_none() {
            break;
        }
    }
}

///
/// The user has pressed down the mouse button: follow the events to track the action
///
async fn track_button_down(input: &mut InputStream<FocusEvent>, context: &SceneContext, control_id: Option<ControlId>, pointer_id: PointerId, initial_state: PointerState, gestures: &mut OutputSink<Gesture>) {
    // When the mouse is first pressed, we send the 'preselect' event
    let Ok(_)               = gestures.send(Gesture::Preselect(control_id, initial_state.clone())).await else { return; };
    let Some(initial_pos)   = initial_state.location_in_canvas else { return; };

    // Process input while the user is dragging the mouse
    while let Some(evt) = input.next().await {
        match evt {
            FocusEvent::Event(_, DrawEvent::KeyDown(_, Some(Key::KeyEscape))) => {
                // The escape key cancels the drag
                gestures.send(Gesture::CancelAction(control_id, initial_state.clone())).await.ok();
                break;
            }

            FocusEvent::Event(event_control, draw_event) => {
                if event_control != control_id {
                    // Events not sent to our target control are just ignored
                    let Ok(_) = gestures.send(Gesture::Focus(FocusEvent::Event(event_control, draw_event))).await else { break; };
                    continue;
                }

                match draw_event {
                    // Certain events have no effect
                    DrawEvent::Pointer(PointerAction::Enter, _, _) => { continue; }
                    DrawEvent::Pointer(PointerAction::Leave, _, _) => { continue; }
                    DrawEvent::Pointer(PointerAction::ButtonDown, _, _) => { continue; }

                    // Releasing the button while in this state finishes selecting the control
                    DrawEvent::Pointer(PointerAction::ButtonUp, up_pointer_id, pointer_state) => {
                        if up_pointer_id != pointer_id { continue; }

                        gestures.send(Gesture::Select(control_id, pointer_state)).await.ok();
                        break;
                    }

                    // Dragging or movign the mouse while the button is down 'pulls' the control until a certain distance is reached
                    DrawEvent::Pointer(PointerAction::Drag, drag_pointer_id, pointer_state) |
                    DrawEvent::Pointer(PointerAction::Move, drag_pointer_id, pointer_state) => {
                        if drag_pointer_id != pointer_id { continue; }

                        let Some(drag_pos)          = pointer_state.location_in_canvas else { continue; };
                        let (offset_x, offset_y)    = (drag_pos.0 - initial_pos.0, drag_pos.1 - initial_pos.1);
                        let distance                = ((offset_x*offset_x) + (offset_y*offset_y)).sqrt();

                        if distance < PULL_DISTANCE {
                            // Pull the control (increasing force pulling it back as it's dragged away)
                            let offset_ratio = (2.0 - (distance / PULL_DISTANCE).powi(2))/2.0;

                            let Ok(_) = gestures.send(Gesture::Pull(control_id, pointer_state, (offset_x * offset_ratio, offset_y * offset_ratio))).await else { break; };
                        } else {
                            // Drag the control
                            track_drag(input, context, control_id, pointer_id, initial_state, gestures).await;
                            break;
                        }
                    }

                    DrawEvent::Pointer(PointerAction::Cancel, cancel_pointer_id, _) => {
                        // If the action is cancelled then specify that as the gesture
                        if cancel_pointer_id != pointer_id { continue; }
                        gestures.send(Gesture::CancelAction(control_id, initial_state.clone())).await.ok();
                        break;
                    }

                    other => {
                        // Pass on other draw events for the control
                        let Ok(_) = gestures.send(Gesture::Focus(FocusEvent::Event(event_control, other))).await else { break; };
                    }
                }
            }

            other => {
                // Other types of events are just forwarded immediately
                let Ok(_) = gestures.send(Gesture::Focus(other)).await else { break; };
            }
        }
    }
}

///
/// The user has pressed down the mouse button and dragged it away
///
async fn track_drag(input: &mut InputStream<FocusEvent>, context: &SceneContext, control_id: Option<ControlId>, pointer_id: PointerId, initial_state: PointerState, gestures: &mut OutputSink<Gesture>) {
    // When the mouse is first pressed, we send the 'preselect' event
    let Ok(_)               = gestures.send(Gesture::Preselect(control_id, initial_state.clone())).await else { return; };
    let Some(initial_pos)   = initial_state.location_in_canvas else { return; };

    // Process input while the user is dragging the mouse
    while let Some(evt) = input.next().await {
        match evt {
            FocusEvent::Event(_, DrawEvent::KeyDown(_, Some(Key::KeyEscape))) => {
                // The escape key cancels the drag
                gestures.send(Gesture::CancelAction(control_id, initial_state.clone())).await.ok();
                break;
            }

            FocusEvent::Event(event_control, draw_event) => {
                if event_control != control_id {
                    // Events not sent to our target control are just ignored
                    let Ok(_) = gestures.send(Gesture::Focus(FocusEvent::Event(event_control, draw_event))).await else { break; };
                    continue;
                }

                match draw_event {
                    // Certain events have no effect
                    DrawEvent::Pointer(PointerAction::Enter, _, _) => { continue; }
                    DrawEvent::Pointer(PointerAction::Leave, _, _) => { continue; }
                    DrawEvent::Pointer(PointerAction::ButtonDown, _, _) => { continue; }

                    // Releasing the button while in this state finishes selecting the control
                    DrawEvent::Pointer(PointerAction::ButtonUp, up_pointer_id, pointer_state) => {
                        if up_pointer_id != pointer_id { continue; }

                        let Some(drag_pos)          = pointer_state.location_in_canvas else { continue; };
                        let (offset_x, offset_y)    = (drag_pos.0 - initial_pos.0, drag_pos.1 - initial_pos.1);

                        gestures.send(Gesture::Drop(control_id, pointer_state, (offset_x, offset_y))).await.ok();
                        break;
                    }

                    // Dragging or movign the mouse while the button is down 'pulls' the control until a certain distance is reached
                    DrawEvent::Pointer(PointerAction::Drag, drag_pointer_id, pointer_state) |
                    DrawEvent::Pointer(PointerAction::Move, drag_pointer_id, pointer_state) => {
                        if drag_pointer_id != pointer_id { continue; }

                        let Some(drag_pos)          = pointer_state.location_in_canvas else { continue; };
                        let (offset_x, offset_y)    = (drag_pos.0 - initial_pos.0, drag_pos.1 - initial_pos.1);

                        gestures.send(Gesture::Drag(control_id, pointer_state, (offset_x, offset_y))).await.ok();
                    }

                    DrawEvent::Pointer(PointerAction::Cancel, cancel_pointer_id, _) => {
                        // If the action is cancelled then specify that as the gesture
                        if cancel_pointer_id != pointer_id { continue; }
                        gestures.send(Gesture::CancelAction(control_id, initial_state.clone())).await.ok();
                        break;
                    }

                    other => {
                        // Pass on other draw events for the control
                        let Ok(_) = gestures.send(Gesture::Focus(FocusEvent::Event(event_control, other))).await else { break; };
                    }
                }
            }

            other => {
                // Other types of events are just forwarded immediately
                let Ok(_) = gestures.send(Gesture::Focus(other)).await else { break; };
            }
        }
    }
}

impl SceneMessage for Gesture {
    fn message_type_name() -> String { "flowbetween::Gesture".into() }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    pub fn convert_event_to_gesture() {
        let scene           = Scene::default();
        let parent_program  = SubProgramId::new();
        let test_program    = SubProgramId::new();

        // Add a subprogram that sends focus events to the test program
        scene.add_subprogram(parent_program, move |input, context| async move {
            // The gesture program intercepts focus events destined for this program
            run_gesture_program(&context).await;

            let mut test_program = context.send(test_program).unwrap();

            // Relay focus events to the test program
            let mut input = input;
            while let Some(gesture) = input.next().await {
                let gesture: Gesture = gesture;
                test_program.send(gesture).await.unwrap();
            }
        }, 20);

        // Test is to send the message to the parent program and expect it to get relayed back to the test program
        TestBuilder::new()
            .send_message_to_target(parent_program, FocusEvent::Event(None, DrawEvent::NewFrame))
            .expect_message_matching(Gesture::Focus(FocusEvent::Event(None, DrawEvent::NewFrame)), "Unexpected Gesture")
            .run_in_scene_with_threads(&scene, test_program, 5);
    }

    #[test]
    pub fn forward_unknown_focus_event_with_filter() {
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        enum TestMessage {
            Focus(FocusEvent),
            Gesture(Gesture)
        }

        impl SceneMessage for TestMessage { }

        let scene           = Scene::default();
        let parent_program  = SubProgramId::new();
        let test_program    = SubProgramId::new();

        // Turn focus and gesture messages into test messages
        // TODO: if we specifiy a filter for focus events, they don't redirect (which perhaps they should do for consistency)
        // scene.connect_programs(StreamSource::Filtered(FilterHandle::for_filter(|evts| evts.map(|evt| TestMessage::Focus(evt)))), (), StreamId::with_message_type::<FocusEvent>()).unwrap();
        scene.connect_programs(StreamSource::Filtered(FilterHandle::for_filter(|evts| evts.map(|evt| TestMessage::Gesture(evt)))), (), StreamId::with_message_type::<Gesture>()).unwrap();

        // Add a subprogram that sends focus events to the test program
        scene.add_subprogram(parent_program, move |input, context| async move {
            // The gesture program intercepts focus events destined for this program
            run_gesture_program(&context).await;

            let mut test_program = context.send(test_program).unwrap();

            // Relay focus events to the test program
            let mut input = input;
            while let Some(test_message) = input.next().await {
                let test_message: TestMessage = test_message;
                test_program.send(test_message).await.unwrap();
            }
        }, 20);

        // Test is to send the message to the parent program and expect it to get relayed back to the test program
        TestBuilder::new()
            .send_message_to_target(parent_program, FocusEvent::Event(None, DrawEvent::NewFrame))
            .expect_message_matching(TestMessage::Gesture(Gesture::Focus(FocusEvent::Event(None, DrawEvent::NewFrame))), "Unexpected Gesture")
            .run_in_scene_with_threads(&scene, test_program, 5);
    }
}