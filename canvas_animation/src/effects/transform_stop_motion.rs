use crate::region::*;
use crate::description::*;

use std::sync::*;
use std::cmp::{Ordering};
use std::time::{Duration};

///
/// Motion effect that's generated by fitting to a curve
///
#[derive(Clone)]
pub struct StopMotionTransformEffect {
    /// The anchor point around which all of the transformations are made
    anchor_point: Point2D,

    /// How the animation region should appear at different times, ordered by time
    transform_points: Vec<TimeTransformPoint>
}

impl StopMotionTransformEffect {
    ///
    /// Creates a stop-motion transform effect that applies the given transformations at the appropriate times
    ///
    pub fn with_points(anchor_point: Point2D, points: Vec<TimeTransformPoint>) -> StopMotionTransformEffect {
        // Sort the points by time
        let mut points = points;
        points.sort_by(|p1, p2| p1.1.partial_cmp(&p2.1).unwrap_or(Ordering::Equal));

        // Create the effect
        StopMotionTransformEffect {
            anchor_point:       anchor_point,
            transform_points:   points
        }
    }

    ///
    /// Finds the transformation to use at a particular point in time
    ///
    pub fn transform_at_time(&self, time: Duration) -> TransformWithAnchor {
        // Get the time in terms of the curve
        let time                = TimeTransformPoint::f64_from_duration(time);

        // Search the points for the one that preceeds the given time
        let default_point       = TransformPoint::default();
        let mut closest_point   = &default_point;

        // Find the point that corrsponds to this time
        for TimeTransformPoint(transform, point_time) in self.transform_points.iter() {
            // Use the selected transform 
            if point_time > &time { break; }

            // This is the latest point we've found
            closest_point = transform;
        }

        // Generate a point with anchor
        TransformWithAnchor(self.anchor_point, *closest_point)
    }
}

impl AnimationEffect for StopMotionTransformEffect {
    ///
    /// Returns the duration of this effect (or None if this effect will animate forever)
    ///
    /// If the effect is passed a time that's after where the 'duration' has completed it should always generate the same result
    ///
    fn duration(&self) -> Option<f64> {
        if self.transform_points.len() == 0 {
            Some(0.0)
        } else {
            Some(self.transform_points[self.transform_points.len()-1].1)
        }
    }

    ///
    /// Given the contents of the regions for this effect, calculates the path that should be rendered
    ///
    fn animate(&self, region_contents: Arc<AnimationRegionContent>, time: Duration) -> Arc<AnimationRegionContent> {
        // Get the transform for the region contents
        let transform   = self.transform_at_time(time);
        let transform   = transform.into();

        // Move all of the paths in the region by the offset
        let paths   = region_contents.paths()
            .map(|path| path.transform_by(&transform));

        Arc::new(AnimationRegionContent::from_paths(paths))
    }

    ///
    /// Given an input region that will remain fixed throughout the time period, returns a function that
    /// will animate it. This can be used to speed up operations when some pre-processing is required for
    /// the region contents, but is not always available as the region itself might be changing over time
    /// (eg, if many effects are combined)
    ///
    fn animate_cached(&self, region_contents: Arc<AnimationRegionContent>) -> Box<dyn Send+Fn(Duration) -> Arc<AnimationRegionContent>> {
        let cached_effect = self.clone();

        Box::new(move |time| {
            // Get the transform for the region contents
            let transform   = cached_effect.transform_at_time(time);
            let transform   = transform.into();

            // Move all of the paths in the region by the offset
            let paths   = region_contents.paths()
                .map(|path| path.transform_by(&transform));

            Arc::new(AnimationRegionContent::from_paths(paths))
        })
    }
}
