use crate::region::*;
use crate::description::*;

use flo_curves::*;
use flo_curves::bezier::*;

use std::sync::*;
use std::cmp::{Ordering};
use std::time::{Duration};

///
/// Motion effect that's generated by fitting to a curve
///
pub struct FittedTransformEffect {
    /// The anchor point around which all of the transformations are made
    anchor_point: Point2D,

    /// The initial point in the motion described by this effect
    start_point: TimeTransformPoint,

    /// The curve for the motion described by this effect
    curve: Vec<TimeCurveTransformPoint>
}

impl FittedTransformEffect {
    ///
    /// Creates a transform effect that smoothly moves through each of the specified points in time
    ///
    pub fn by_fitting_transformation(anchor_point: Point2D, points: Vec<TimeTransformPoint>) -> Option<FittedTransformEffect> {
        // Sort the points by time
        let mut points = points;
        points.sort_by(|p1, p2| p1.1.partial_cmp(&p2.1).unwrap_or(Ordering::Equal));

        // Attempt to fit a curve to these points
        let curves = fit_curve::<TimeTransformCurve>(&points, 0.01)?;

        if curves.len() == 0 {
            // We found a fit but it had nothing in it
            None
        } else {
            // Create the transform effect from the fitted curves
            let start_point     = curves[0].start_point();
            let curve_sections  = curves.into_iter()
                .map(|TimeTransformCurve(_start_point, section)| section)
                .collect();

            Some(FittedTransformEffect {
                anchor_point:   anchor_point,
                start_point:    start_point,
                curve:          curve_sections
            })
        }
    }
}